package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"text/template"

	"github.com/fatih/structtag"
	"golang.org/x/tools/imports"
)

const (
	AccessRead    = "r"
	AccessWrite   = "w"
	AccessTagName = "access"

	ModeTypeAll    = 0
	ModeTypeGetter = 1
	ModeTypeSetter = 2
)

var (
	fileName = flag.String("file", "", "a parsed filename must be set if you use command line")
	modeType = flag.Int("mode", 0, "when mode=0 or not set, gen Getter and Setter!\n"+
		"when mode=1, only gen Getter method!\n"+
		"when mode=2, only gen Setter method!\n"+
		"when mode is other num, not support!")
)

func main() {
	log.SetFlags(0) // è®¾ç½®æ—¥å¿—çš„æŠ¬å¤´ä¿¡æ¯
	log.SetPrefix("gentools-accessor: ")
	flag.Parse() //æŠŠç”¨æˆ·ä¼ é€’çš„å‘½ä»¤è¡Œå‚æ•°è§£æä¸ºå¯¹åº”å˜é‡çš„å€¼

	var mode int
	if modeType != nil {
		if *modeType < 0 || *modeType > 2 {
			log.Fatalln("\n\tThe -mode parameter setting is out of range, please execute the command to check the meaning of the parameter: \n\t\t>>>\tgentools-accessor -h")
			return
		} else {
			mode = *modeType
		}
	}

	var inputName string
	if len(*fileName) > 0 {
		inputName = *fileName
	} else {
		//å°è¯•è·å–å½“å‰è¢«æ‰§è¡Œçš„æ–‡ä»¶
		inputName = os.Getenv("GOFILE")
	}

	if len(inputName) == 0 {
		log.Fatalln("Please enter a correct file path to be parsedï¼")
		return
	}
	log.Println("\n\t\nThe currently executed fileName is: ", inputName)

	g := Generator{
		buf: bytes.NewBufferString(""),
	}
	g.generate(inputName, mode)
	src := g.formatCode()
	outputName := strings.TrimSuffix(inputName, ".go") + ".accessor.go"
	err := ioutil.WriteFile(outputName, src, 0644) // ignore_security_alert
	if err != nil {
		log.Fatalf("writing output: %s\n", err)
		return
	}
	log.Printf("\n\tğŸ‰ğŸ‰ğŸ‰ Congratulationï¼\n\tAutomatic code generation finished!\n\tOutput_name: %s\n", outputName)
}

type StructFieldInfo struct {
	Name   string   // å­—æ®µå
	Type   string   // ç±»å‹å
	Access []string // tagå¯¹åº”çš„valueï¼Œå³ä¸ºrï¼Œw
}

type StructFieldInfoArr = []StructFieldInfo

type Generator struct {
	buf *bytes.Buffer // Accumulated output.
}

// FormatCode sets the options of the imports pkg and then applies the Process method
// which by default removes all of the imports not used and formats the remaining docs,
// imports and code like `gofmt`. It will e.g. remove paranthesis around a unnamed single return type
func (g *Generator) formatCode() []byte {
	opts := &imports.Options{
		TabIndent: true,
		TabWidth:  2,
		Fragment:  true,
		Comments:  true,
	}
	src := (g.buf).Bytes()
	fmtCode, err := imports.Process("", src, opts)
	if err != nil {
		log.Fatalln("æ ¼å¼åŒ–ä»£ç å¤±è´¥")
		return src
	}
	return fmtCode
}

func (g *Generator) myPrintf(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(g.buf, format, args...)
}

func (g *Generator) generate(fileName string, modeVal int) {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, fileName, nil, parser.ParseComments)
	if err != nil || f == nil {
		log.Fatalln("parse file err")
		return
	}
	structInfo, err := parseAllStructInSingleFile(f, fset, AccessTagName, modeVal)
	if err != nil {
		log.Fatalln("parse structs in file err: ", err)
		return
	}
	g.myPrintf("// Code generated by \"gentools-accessor\"; DO NOT EDIT.\n")
	g.myPrintf("\n")
	g.myPrintf("package %s\n", f.Name)
	g.myPrintf("\n")
	// å°†æºæ–‡ä»¶å¯¼å…¥çš„åŒ…åå†™å…¥
	if len(f.Imports) > 0 {
		g.myPrintf("%s\n", genImports(f.Imports))
	}
	for stName, info := range structInfo {
		// è¿™é‡Œå¯ä»¥ç»´æŠ¤ä¸€ä¸ªmapï¼Œå¯¹ä»…ä»…æ˜¯å¤§å°å†™å­—æ¯åŒºåˆ«çš„åšæ ‡è®°
		visMap := make(map[string]int)
		for index, field := range info {
			lowerName := strings.ToLower(field.Name)
			if d, exist := visMap[lowerName]; exist {
				log.Fatalf("æœ‰ä¸¤ä¸ªå«ä¹‰ç›¸è¿‘çš„å‘½åï¼š%s å’Œ %sï¼Œè¯·æ”¹æ­£ï¼ç»ˆæ­¢ç”Ÿæˆä»£ç ï½\n", lowerName, info[d].Name)
				return
			}
			visMap[lowerName] = index
			for _, access := range field.Access {
				switch access {
				case AccessWrite:
					g.myPrintf("%s\n", genSetter(stName, field.Name, field.Type))
				case AccessRead:
					g.myPrintf("%s\n", genGetter(stName, field.Name, field.Type))
				}
			}
		}
	}
}

// firstUpper å­—ç¬¦ä¸²é¦–å­—æ¯å¤§å†™
func firstUpper(s string) string {
	if s == "" {
		return ""
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func parseAllStructInSingleFile(file *ast.File, fileSet *token.FileSet, tagName string, modeVal int) (structMap map[string]StructFieldInfoArr, err error) {
	structMap = make(map[string]StructFieldInfoArr)

	collectStructs := func(x ast.Node) bool {
		ts, ok := x.(*ast.TypeSpec)
		if !ok || ts.Type == nil {
			return true
		}

		// è·å–ç»“æ„ä½“åç§°
		structName := ts.Name.Name

		s, ok := ts.Type.(*ast.StructType)
		if !ok {
			return true
		}
		fileInfos := make([]StructFieldInfo, 0)
		for _, field := range s.Fields.List {
			if len(field.Names) == 0 { // Notice: è·³è¿‡ç»„åˆstructçš„å­—æ®µ
				continue
			}
			name := field.Names[0].Name // å­—æ®µåç§°
			info := StructFieldInfo{Name: name}
			var typeNameBuf bytes.Buffer
			err := printer.Fprint(&typeNameBuf, fileSet, field.Type)
			if err != nil {
				log.Println("è·å–å­—æ®µç±»å‹å¤±è´¥:", err)
				return true
			}
			info.Type = typeNameBuf.String()
			if field.Tag != nil { // æœ‰tag
				tag := field.Tag.Value
				tag = strings.Trim(tag, "`")
				tags, err := structtag.Parse(tag)
				if err != nil {
					return true
				}
				access, err := tags.Get(tagName)
				if err == nil {
					access.Options = append(access.Options, access.Name)
					for i, v := range access.Options {
						if v == AccessRead || v == AccessWrite {
							continue
						}
						// å‰”é™¤é™¤ r,w ä¹‹å¤–çš„ tag-value
						access.Options = append(access.Options[:i], access.Options[i+1:]...)
					}
				}
				info.Access = access.Options
			} else {
				if modeVal == ModeTypeAll { // æ¨¡å¼ä¸º0ï¼Œå°è£…å¯è¯»å¯è¯»æ–¹æ³•
					info.Access = []string{AccessRead, AccessWrite}
				} else if modeVal == ModeTypeGetter { // æ¨¡å¼ä¸º1ï¼Œåªå°è£…å¯è¯»æ–¹æ³•
					info.Access = []string{AccessRead}
				} else if modeVal == ModeTypeSetter { // æ¨¡å¼ä¸º2ï¼Œåªå°è£…å¯å†™æ–¹æ³•
					info.Access = []string{AccessWrite}
				}
			}
			fileInfos = append(fileInfos, info)
		}
		structMap[structName] = fileInfos
		return false
	}

	ast.Inspect(file, collectStructs)

	return structMap, nil
}

func genImports(importsArr []*ast.ImportSpec) string {
	packageNameArr := make([]string, 0)
	for _, s := range importsArr {
		if s.Name != nil {
			packageNameArr = append(packageNameArr, fmt.Sprintf("%s %s\n", s.Name.Name, s.Path.Value))
		} else {
			packageNameArr = append(packageNameArr, s.Path.Value)
		}
	}
	tpl := `import (
		{{range .}}
			{{- .}}
		{{end -}}
	)`
	t := template.New("imports")
	t = template.Must(t.Parse(tpl))
	res := bytes.NewBufferString("")
	_ = t.Execute(res, packageNameArr)
	return res.String()
}

func genSetter(structName, fieldName, typeName string) string {
	tpl := `func ({{.Receiver}} *{{.Struct}}) Set{{.MethodName}}(param {{.Type}}) {
	{{.Receiver}}.{{.Field}} = param
}`
	t := template.New("setter")
	t = template.Must(t.Parse(tpl))
	res := bytes.NewBufferString("")
	_ = t.Execute(res, map[string]string{
		"Receiver":   strings.ToLower(structName[0:1]),
		"Struct":     structName,
		"Field":      fieldName,
		"Type":       typeName,
		"MethodName": firstUpper(fieldName),
	})
	return res.String()
}

func genGetter(structName, fieldName, typeName string) string {
	tpl := `func ({{.Receiver}} *{{.Struct}}) Get{{.MethodName}}() (v0 {{.Type}}) {
	if {{.Receiver}} == nil {
		return
	}
	return {{.Receiver}}.{{.Field}}
}`
	t := template.New("getter")
	t = template.Must(t.Parse(tpl))
	res := bytes.NewBufferString("")
	_ = t.Execute(res, map[string]string{
		"Receiver":   strings.ToLower(structName[0:1]),
		"Struct":     structName,
		"Field":      fieldName,
		"Type":       typeName,
		"MethodName": firstUpper(fieldName),
	})
	return res.String()
}
